<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        //자바스크립트는 항상 동기식 처리 (synchronous)
        //동기식 처리란: 한번에 코드 한줄씩 차례차례 실행 자바스크립트를 실행하는 웹브라우저는 stack이라는 코드 실행 공간이 있는데 거기서 코드를 한줄한줄 차례로 실행합니다. 

        console.log(1);
        console.log(2);
        console.log(3);
        //1,2,3이 차례로 출력

        //비동기처리 (asynchronous)라는 것도 가능합니다.
        console.log(1);
        setTimeout(function () { }, 1000);
        console.log(2);
        // 1과 2가 콘솔창에 동시에 출력
        //자바스크립트 실행머신인 웹브라우저는 이런 특수한 코드들을 발견하면 약간 제쳐두고 다른 코드부터 실행하려고 합니다.
        //그래서 setTimeout() 을 제껴두고 그 밑에 있는 console.log(2)라는 코드 부터 실행하는데 이런 처리방식을 바로 비동기(asynchronous)
        //실행이 오래걸리는 그런 코드들은 잠깐 대기실에 제쳐두고, 실행이 바로바로 가능한 코드들부터 처리하는 방식을 뜻합니다.
        //이건 자바스크립트 언어 자체의 기능이 아니라 자바스크립트 실행을 도와주는 웹브라우저 덕분에 가능합니다.
        //제쳐준 코드가 들어가있는 대기실 =>실행을 미루고 옆으로 잠깐 제껴둘 수 있는 코드들은 미리 정해져있습니다. setTimeout, addEventListener, ajax 관련 함수들이 그렇습니다.
        //setTimeout, addEventListener, ajax관련 함수들은 1초대기, 클릭대기 이런걸 하는 코드들인데 이런 코드들의 특징은 읽는 시점과 동작 시점이 차이가 있습니다. (쉽게 말하면 동작까지 오래걸립니다.)
        console.log(1);
        setTimeout(function () { }, 1000);
        console.log(2);
        //크롬은 위의 코드를 읽다가 setTimeout 이런 코드를 만나면 잠시 Web API 대기실로 옮겨서 대기시킵니다.
        //그리고 1초의 대기시간이 지나고 setTimeout이 완료가 되면 대기실에서 코드를 꺼내서 코드가 실행되게 만들어줍니다. 이것 덕분에 setTimeout같이 시간이 오래걸리는 코드들을 비동기식으로 처리할 수 있는 것입니다.
        //그래서 자바스크립트는 평소에 동기식으로 처리하는데 비동기를 지원하는 setTimeout 같은 함수를 이용하면 비동기식으로 동작하게 만들 수 있는 언어입니다.
        // 즉,자바스크립트를 실행하고 해석하는 크롬은 이런 특별한 코드들을 만나면 1. 잠깐 대기실에 제껴두고 2. 준비가 완료되면 다시 실행시킵니다.

        //콜백함수를 이용한 순차적 실행
        console.log(1);
        setTimeout(function () {
            console.log(2);
        }, 1000);
        console.log(3);
        //자바스크립트에서 1초 후에 코드를 실행하고 싶을땐 위와 같이 코드를 짜면 되는데 이렇게 되면 그러면 콘솔창에 1과 3이 먼저 출력되고 그 다음 1초 후에 2가 출력됩니다.
        //자바스크립트는 비동기상황 등에서 코드를 순차적으로 실행하고 싶을 때 콜백함수를 적극 활용합니다.
        //여기서 콜백함수란 =>함수안에 들어가는 함수를 전부 콜백함수

        //콜백함수 디자인하는 법
        //ex)순차적으로 실행하고 싶은 함수가 두개가 있을 때 
        function 첫째함수() {
            console.log(1)
        }

        function 둘째함수() {
            console.log(2)
        }

        첫째함수();
        둘째함수();
        //이렇게 짜면 자바스크립트는 비동기라는 특수성으로 인해 이렇게 쓴다고 순차적으로 실행하는걸 보장하진 않습니다. (첫째함수가 setTimeout이거나 Web API 대기실로 보내는 코드라면 나중에 실행될수 있습니다.)
        //해결 방법은 콜백함수를 만들어서 첫째함수(둘째함수); 이런 식으로 실행하면 순차적으로 실행 가능
        function 첫째함수(콜백) {
            console.log(1);
            콜백();
        }

        function 둘째함수() {
            console.log(2)
        }

        첫째함수(둘째함수);
        //함수에 파라미터를 하나 뚫으면 됩니다! 그리고나서 그 파라미터에 소괄호를 붙여서 실행해주세요~라고 하면 함수안에 함수를 집어넣어서 실행이 가능합니다. 이게 콜백함수 디자인하는 법입니다.
        //위처럼 미리 만들어놓은 함수를 집어넣을 수도 있고 또 다른 방법은
        첫째함수(function () {
            console.log(2)
        }):
        //이렇게 직접 함수선언문을 집어넣는 방법도 있습니다.

        //그런데 순차적으로 실행하려고 콜백함수를 여러개 사용하면 단점이 발생합니다.
        첫째함수(function () {
            둘째함수(function () {
                셋째함수(function () {
                    어쩌구..
    });
            });
        }):
        //코드가 옆으로 길어지는 단점이 발생합니다.
        //첫째함수 둘째함수 셋째함수 이렇게 차례로 실행해주는 코드입니다. 특히 자바스크립트로 서버개발시 이런 패턴이 흔한데 이 방식이 불편할땐 ES6 신문법인 Promise라는 기계를 만들어 사용하면 됩니다.
    </script>

</body>

</html>