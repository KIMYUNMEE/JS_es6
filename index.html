<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
    //object를 안전하게 많이 복사해 만들 수 있는 constructor라는 문법
    function 기계() {
            this.name = 'Kim';
            this.age = 15;
        }
    //object 자료 복사 기계만들 땐 function이라는 함수만드는 키워드로 만듭니다.
    //function을 만들고 그 안에 this.name과 this.age를 넣으면 됩니다. 이게 오브젝트 생성 기계입니다
    //this는 새로생성되는 오브젝트를 뜻합니다. 개발용어로는 인스턴스라고 합니다.
    //여기서 this란 새로생성되는 오브젝트.name은 'Kim'을 넣어주세요~ 라는 뜻입니다.

    //이제 기계에서 새로운 오브젝트를 뽑고 싶을때에는 
    function 기계() {
            this.name = 'Kim';
            this.age = 15;
        }

        var 학생1 = new 기계();
        var 학생2 = new 기계();
    //new라는 키워드를 쓰신 다음 오른쪽에 기계(constructor) 이름을 쓰면 기계로부터 새로운 오브젝트를 하나를 뽑아낼 수 있습니다. 
    //그리고 그걸 변수에 저장하시면 이제 자유롭게 오브젝트를 뽑아 쓸수 있습니다.
    //기계를 사용하면 비슷한 + 독립적인 object 자료를 여러개 만들 때 코드의 양이 줄어듭니다.

    //오브젝트에 함수가 들어가야 한다면
    var 학생1 = {
            name: 'Kim',
            age: 15 
    sayHi: function () {
                console.log('안녕하세요' + this.name + ' 입니다');
            }
        };

        학생1.sayHi();
    //학생1.sayHi()하면 콘솔에 "안녕하세요 'Kim'입니다"라고 이름이 포함된 말이 출력됩니다.
    //그런데 앞으로 모든 학생들이 sayHi()를 쓸 수 있게 만들고 싶으면 어떻게 해야할까요? =>오브젝트 생성기계에 추가한다
    function 기계() {
        this.name = 'Kim';
        this.age = 15;
        this.sayHi = function () {
            console.log('안녕하세요' + this.name + ' 입니다');
        }
    }
    var 학생1 = new 기계();
    var 학생2 = new 기계();

    학생2.sayHi();
    //기계에 this.sayHi 를 추가하시면 이제 기계로부터 생성되는 모든 학생들이 sayHi()를 가지고 있게 됩니다. 그럼 학생1, 학생2 전부 sayHi()를 쓸 수 있게됩니다. 

    //학생 오브젝트를 뽑을 때 각각 다른 name, age 값을 부여하고 싶다면
    //바로 위의 코드를 보면 학생1이나 학생2나 name이 똑같은데 만약 name 속성을 각각 다르게 해서 뽑고싶으면 함수에 파라미터를 추가하는 방식을 사용하면 됩니다.
    function 기계(이름) {
            this.name = 이름;
            this.age = 15;
            this.sayHi = function () {
                console.log('안녕하세요' + this.name + ' 입니다');
            }
        }
        var 학생1 = new 기계('Park');
        var 학생2 = new 기계('Kim');
    //함수에 파라미터를 추가한다면 앞으로 기계라는 함수를 쓸 때마다파라미터자리에 데이터를 넣어서 실행할 수 있는 것입니다. =>'Park','Kim'
    //그 'Park' 이라는 데이터는 파라미터자리에 쏙 들어가서 함수가 실행되게 되며 그럼 새로 생성되는 오브젝트의 name속성은 'Park'이 됩니다. (this.name = 'Park')
    //학생1은 { name: 'Park', age : 15 } 학생2는 { name: 'Kim', age : 15 }

    //constructor은 객체지향 용어로 상속(inheritance)라고 합니다.
    //기계라는 constructor가 가진 name, age 속성들을 그대로 물려받아서 오브젝트를 하나 뽑아주는걸 상속이라고 부릅니다. (그래서 상속해주는 것은 부모, 상속받는 오브젝트들은 자식이라고 많이 비유해서 부릅니다.)
    // constructor 말고도 상속기능을 구현할 수 있는 장치가 하나 더 있습니다. prototype입니다.
    //기계를 만드시면 prototype이라는 항목이 기계 안에 몰래 생성됩니다. 
    function 기계() {
            this.name = 'Kim';
            this.age = 15;
        }
        var 학생1 = new 기계();
        var 학생2 = new 기계();

        console.log(기계.prototype);
        //prototype이라는 공간은 바로 부모의 유전자역할을 해주는 일종의 비밀 공간이다.
        //prototype은 자식들이 물려받을 수 있는 유전자로 기계.prototype은 기계의 유전자입니다. 기계.prototype 에 뭔가 변수나 함수가 들어가있다면 기계로부터 생성되는 새로운 오브젝트들(자식들)은 전부 그걸 그대로 물려받아 쓸 수 있습니다.
       
        //예를 들어
        function 기계() {
                this.name = 'Kim';
                this.age = 15;
            }

            기계.prototype.gender = '남';
            var 학생1 = new 기계();
            var 학생2 = new 기계();

            console.log(학생1.gender); //'남'이 출력됩니다
            //기계의 prototype이라는 곳에 { gender : '남' } 이라는 key/value 한쌍을 저장했습니다. (prototype은 오브젝트 자료형 다루듯이 하면 됩니다)
            //기계의 prototype, 즉 유전자에 gender: '남'이라는 데이터를 추가한 것입니다. 이제 학생1, 학생2 같은 기계로부터 생성되는 모든 자식들은 gender라는 속성을 사용할 수 있습니다. 
            //결론은 prototype 이라는 비밀 공간을 이용하시면 똑같이 상속기능을 만들 수 있습니다. 
            //1.prototype에는 값을 여러개 부여할 수도 있고 심지어 함수도 집어넣으실 수 있습니다.object 자료처럼 다뤄주시면 됩니다. 
            //2.prototype에 추가된 데이터들은 자식들이 직접 가지는게 아니라 부모만 가지고 있습니다. 

            //<prototype으로 상속시키는거랑 constructor로 상속시키는거랑 차이>
            //자식들이 값을 직접 소유하게 만들고 싶으면 constructor로 상속시키시면 되고 부모만 가지고 있고 그걸 참조해서 쓰게 만들고 싶으면 prototype으로 상속시키면 됩니다.

            // prototype 특징!!
            //1.prototype은 constructor 함수에만 생성됩니다. <= 일반 object 같은걸 상속하고 싶을땐 constructor 함수를 만들거나 Object.create()를 쓰거나 class를 쓰거나 셋중 하나를 사용하면 된다.
            //2.내 부모님 유전자를 찾고 싶다면 __proto__를 출력해보시면 됩니다. => 부모로부터 생성된 자식 object들은 __proto__라는 속성이 있습니다. 이걸 출력하면 부모의 prototype이 출력됩니다. 그래서 __proto__는 부모의 prototype과 같은 의미입니다. 
            function 기계() {
                    this.name = 'Kim';
                    this.age = 15;
                }
                var 학생1 = new 기계();
                console.log(학생1.__proto__);
                console.log(기계.prototype);
            //출력해보면 학생1.__proto__ 기계.prototype 둘다 똑같이 나옵니다.  그래서 __proto__는 부모 prototype을 의미합니다. __proto__는 내 부모 유전자가 뭔지 유전자 검사하고 싶을 때 사용하면 됩니다.

            //3.__proto__를 직접 등록하면 object끼리 상속기능을 구현가능합니다.
            var 부모 = { name: 'Kim' };
                var 자식 = {};

                자식.__proto__ = 부모;
                console.log(자식.name);
            //부모와 자식 object를 하나씩 만들고 셋째줄에서 자식의 __proto__에 부모를 집어넣었습니다. 그렇게되면 자식의 부모 유전자는 { name: 'Kim' } 이라는 오브젝트가 되는 것입니다.
            //그렇게 되면 자식은 이제 자식.name 속성을 자유롭게 사용할 수 있습니다. 

            //4.콘솔창에 prototype 정보들이 항상 출력됩니다.
            function 기계() {
                    this.name = 'Kim';
                    this.age = 15;
                }
                기계.prototype.gender = '남';

                var 학생1 = new 기계();
            //출력하면 __proto__ 가 나옵니다.  __proto__는 부모의 유전자로 기계.prototype이랑 똑같은 내용이 출력됩니다.
            //그리고 기계.prototype의 __proto__도 조회가능합니다.=>기계.prototype의 부모 유전자
            //이런식으로 나의 부모의 부모까지 탐색할 수 있습니다. 탐색하면 모든 object 자료형의 조상은 Object() 라는 기계이며(일명 Object.prototype) 모든 array 자료형의 조상도 Object()입니다. (중간에 Array()라는 부모도 있습니다.)
            //모든 함수 자료형의 조상도 Object() 입니다. =>그래서 자바스크립트는 모든게 다 Object라고 말하는 것입니다.

            //prototype이나,this,class보다 더쉬운 상속을 이용해서 오브젝트를 만드는 방법은 ES5방식이 있는데 인지도는 낮습니다.=>Object.create()
            var 부모 = { name: 'Kim', age: 50 };
                var 자식 = Object.create(부모);

                console.log(자식.age); //50나옴
            //Object.create(부모object);는 이 자리에 오브젝트 자료형 하나가 남습니다. 그리고 소괄호 안에 적은 부모object가 유전자(prototype)가 되는 것입니다.
            //위의 예제를 보면 자식이라는 object는 부모를 prototype으로 두게 됩니다. 자식.name 해도 'Kim'이 출력되고 자식.age 해도 50이 출력됩니다.(이렇게 하면 쉽게 상속할 수 있습니다.)

            //위의 예제의 age를 20으로 바꾸고 싶다면?
            var 부모 = { name: 'Kim', age: 50 };
                var 자식 = Object.create(부모);
                자식.age = 20;

                console.log(자식.age); //20 나옴
            //자식이라는 object에 age : 20 이라는 값을 부여하면 자식.age 할 때마다 20이 출력됩니다.
            //Q:부모로부터 상속받은 50이라는 age가 출력되지 않는 이유는?
            //A:자바스크립트 오브젝트 자료형에서 특정 자료를 꺼낼 때 묻는 순서가 있다고 배웠었습니다. 자식.age를 꺼내주세요~라고 하면
            //A:1. 자식이라는 object가 직접 age를 가지고 있으면 그거 출력 2. 없으면 자식의 부모 prototype을 뒤져서 age가 거기 있으면 그거 출력 3. 거기도 없으면 부모의 부모 prototype을 탐색해서..
            //위와 같은 순서로 age를 출력하기 때문에 자식이 20이 나오는 것입니다.
            
            //자식을 넘어서 손자를 만드려면?
            var 부모 = { name: 'Kim', age: 50 };
                var 자식 = Object.create(부모);
                자식.age = 20;

                var 손자 = Object.create(자식);

                console.log(손자.age);
            //손자는 자식과 부모가 가진 속성들을 전부 물려받습니다. 그래서 손자.age는 20이 출력됩니다.
            //Q:20이 나오는 이유는?
            //A:1. 손자에 age가 있는지 확인하고 2. 없으면 부모 prototype에 있는지 확인하고 3. 거기도 없으면 부모의 부모 prototype에 있는지 확인하고..
            //A:이렇게 하나씩 확인해서 젤 가까운 age를 출력시키기 때문입니다. 
        
            //ES6방식으로 안쉽게 구현하는 상속기능 (class)
            class 부모 {
                    constructor() {
                        this.name = 'Kim'
                    }
                }

                var 자식 = new 부모();
            //이렇게 기계를 만드는 문법이고 이제 new 키워드를 이용해서 방금 만든 부모라는 기계에서 오브젝트를 새로 생성할 수 있습니다.
            //constructor()라고 쓴 부분에 예전처럼 this.name 이런식으로 쓰면 새로 생성되는 오브젝트들에 값을 부여할 수 있습니다. 

            //상속가능한 함수를 추가하려면?
            //1.함수를 this.sayHi 이렇게 constructor 안에 추가하는 방법
            class 부모 {
                    constructor() {
                        this.name = 'Kim';
                        this.sayHi = function () { console.log('hello') }
                    }
                }

                var 자식 = new 부모();
            //2.기계의 prototype에 추가하는 방법
            class 부모 {
                    constructor() {
                        this.name = 'Kim';
                    }
                    sayHi() {
                        console.log('hello')
                    }
                }

                var 자식 = new 부모();
            //그럼 자식은 sayHi()라고 썼을 때 부모의 prototype에 있던 sayHi() 함수를 쓸 수 있습니다.(혹은 그냥 부모.prototype.sayHi = function () { } 이렇게 해도 됩니다)
            //참고사항! =>Object.getPrototypeOf() 이 함수 안에 오브젝트를 넣으시면 부모 prototype을 출력해줍니다. 이 오브젝트가 누구로부터 prototype을 상속받고 있는지를 알려주는 함수로 __proto__라는 키워드와 비슷한 역할을 합니다.
            
            //constructor안에 파라미터 추가하기
            class 부모 {
                    constructor(이름, 나이) {
                        this.name = 이름;
                        this.age = 나이;
                    }
                }

                var 자식 = new 부모('Park', 30);
            //prototype 내에 함수 여러개 추가하기
            class 부모 {
                    constructor(이름, 나이) {
                        this.name = 이름;
                        this.age = 나이;
                    }
                    sayHi() {
                        console.log('안녕');
                    }
                    sayHello() {
                        console.log('안녕하세요');
                    }
                }

                var 자식 = new 부모('Park');
            // 이런식으로 작성하면 prototype에 sayHi, sayHello 등 여러개 함수를 동시에 넣을 수 있습니다.

            //객체지향 문법의 끝판왕인 extends
            class 할아버지 {
                    constructor(name) {
                        this.성 = 'Kim';
                        this.이름 = name;
                    }
                }
            //할아버지 class는 성과 이름이라는 속성을 가지고 있습니다. 
            //이제 new 할아버지() 뭐 이런식으로 하면 새로운 object를 쉽게 생성할 수 있습니다.
            //이 class가 너무나도 유용한 나머지 이것과 유사한 class를 하나 더 만들고 싶을 때 직접 class를 하나 더 만들어서 내용을 복붙하면 되겠지만 class안에 복사할 내용이 너무나도 많으면 코드가 너무나도 길어집니다. 
            //그래서 고대의 개발자들이 extends라는 문법을 만들었는데 이걸 이용해서 class를 만들면 기존에 있던 class의 내용을 그대로 복붙해서 만들어낼 수 잇습니다. 즉, "다른 class를 상속해서 만들 수 있게 도와주는 문법"입니다.
            //그래서 할아버지 class를 상속하는 아버지 class를 만드는 방법은 extends를 쓰면 됩니다.
            class 할아버지 {
                    constructor(name) {
                        this.성 = 'Kim';
                        this.이름 = name;
                    }
                }

                class 아버지 extends 할아버지 {

                }
            //그럼 이제 할아버지라는 class를 그대로 복붙한 아버지라는 class가 생성됩니다. new 아버지('만수'); 이렇게 하면 성과 이름을 가진 object 자료가 하나 생성됩니다.

            //근데 아버지라는 class에는 새로운 속성을 추가하고 싶으면?!
            class 할아버지 {
                    constructor(name) {
                        this.성 = 'Kim';
                        this.이름 = name;
                    }
                }

                class 아버지 extends 할아버지 {
                    constructor() {
                        this.나이 = 50;
                    }
                }
            //아버지 constructor안에 내용을 추가하면 됩니다.
            //이렇게 하면 new 아버지() 했을 때 생성된 오브젝트들은 {성, 이름, 나이} 속성들을 가지는데 super를 사용하라는 에러가 뜹니다.
            class 할아버지 {
                    constructor(name) {
                        this.성 = 'Kim';
                        this.이름 = name;
                    }
                }

                class 아버지 extends 할아버지 {
                    constructor() {
                        super();
                        this.나이 = 50;
                    }
                }
            //super()함수는"extends로 상속중인 부모 class의 constructor()"를 의미합니다. 쉽게 말하자면 할아버지 class의 constructor()랑 똑같은 말입니다. 그래야 에러없이 this.나이 이런걸 추가할 수 있습니다.

            //그런데 할아버지 class의 constructor()에는 name 파라미터를 입력할 수 있었는데 똑같이 따라서 명시해야 할아버지가 가진 모든 속성들을 상속받을 수 있습니다. 
            class 할아버지 {
                    constructor(name) {
                        this.성 = 'Kim';
                        this.이름 = name;
                    }
                }

                class 아버지 extends 할아버지 {
                    constructor(name) {
                        super(name);
                        this.나이 = 50;
                    }
            //할아버지 constructor()에 name이라는 파라미터가 있던걸 그대로 아버지 constructor()에도 따라했습니다. (파라미터 작명은 자유롭게 가능)
            //그럼 이제 new 아버지(); 할 때 파라미터를 입력하면 this.이름 속성에 들어가게 됩니다.
            //Q:하단에 var a = new 아버지('만수'); 이렇게 적으면 a라는 변수는 어떤 내용을 가지고 있을까요?
            //A:1 a라는 변수는 아버지라는 class로부터 새로 생성된 오브젝트입니다. 
            //A:2.할아버지가 가지고 있던 성, 이름 그리고 아버지가 가지고 있던 나이를 전부 물려받았습니다.
            //A:3.그리고 this.이름 자리에는 '만수'를 넣어 실행했습니다.
            //A:그래서 { 성: 'Kim', 이름 : '만수', 나이 : 50 } 이라는 오브젝트가 됩니다. 

            //할아버지에 메소드(함수)를 추가한다면?!
            class 할아버지 {
                    constructor(name) {
                        this.성 = 'Kim';
                        this.이름 = name;
                    }
                    sayHi() {
                        console.log('안녕 나는 할아버지')
                    }
                }

                class 아버지 extends 할아버지 {
                    constructor(name) {
                        super(name);
                        this.나이 = 50;
                    }
                }

                var a = new 아버지('만수');
            //그럼 이제 a라는 오브젝트는 sayHi()라는 함수를 쓸 수있습니다.
            //a라는 오브젝트가 a.sayHi() 이렇게 사용한다면
            //1. a라는 오브젝트에 sayHi가 있는지 물어보고
            //2. 없으면 아버지.prototype에 sayHi가 있는지 물어보고
            //3. 없으면 할아버지.prototype에 sayHi가 있는지 물어보고 이런 식으로 sayHi를 실행하기 위해 부모님을 찾아봅니다.
            //근데 sayHi()라는건 할아버지.prototype에 추가된 함수이기 때문에 a라는 오브젝트는 sayHi() 함수를 실행할 수 있습니다. 

            //근데 class간에 함수를 상속하고 싶을때는 어떻게 할까요?
            //아버지라는 class에 함수를 만들고 싶습니다. 근데 할아버지 class에 있던 sayHi()라는 함수가 유용해 이걸 그대로 아버지 class에 가져와서 활용하고 싶은 것입니다. 
            //=>그럴때는 super를 쓰면 됩니다.
            class 할아버지 {
                    constructor(name) {
                        this.성 = 'Kim';
                        this.이름 = name;
                    }
                    sayHi() {
                        console.log('안녕 나는 할아버지')
                    }
                }

                class 아버지 extends 할아버지 {
                    constructor(name) {
                        super(name);
                        this.나이 = 50;
                    }
                    sayHi2() {
                        console.log('안녕 나는 아버지');
                        super.sayHi();
                    }
                }

                var a = new 아버지('만수');
            //super라는걸 저렇게 prototype 함수 안에서 쓰면 아까의 super와 다른 의미가 됩니다.여기서의 super는 부모 class의 prototype을 의미합니다.
            //즉, super는 뜻이 두개입니다. 1. constructor 안에서 쓰면 부모 class의 constructor 2. prototype 함수 안에서 쓰면 부모 class의 prototype
            //Q:그럼 위의 예제 코드에서 a.sayHi2()를 실행하면 무엇이 콘솔창에 출력될까요?
            //A:a.sayHi2()를 사용하신다면 아버지.prototype에 있던 sayHi2 함수가 동작합니다. 
            //A:그 함수는 일단 console.log('안녕 나는 아버지')를 실행하고 둘째 줄에서 super.sayHi()를 실행합니다.
            //A:즉, 할아버지.prototype.sayHi()와 똑같기 때문에 console.log('안녕 나는 할아버지')를 실행할 것입니다. 
            //A:그래서 콘솔창에 "안녕 나는 아버지" "안녕 나는 할아버지"가 출력됩니다.
    </script>
</body>
</html>