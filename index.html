<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
    //object를 안전하게 많이 복사해 만들 수 있는 constructor라는 문법
    function 기계() {
            this.name = 'Kim';
            this.age = 15;
        }
    //object 자료 복사 기계만들 땐 function이라는 함수만드는 키워드로 만듭니다.
    //function을 만들고 그 안에 this.name과 this.age를 넣으면 됩니다. 이게 오브젝트 생성 기계입니다
    //this는 새로생성되는 오브젝트를 뜻합니다. 개발용어로는 인스턴스라고 합니다.
    //여기서 this란 새로생성되는 오브젝트.name은 'Kim'을 넣어주세요~ 라는 뜻입니다.

    //이제 기계에서 새로운 오브젝트를 뽑고 싶을때에는 
    function 기계() {
            this.name = 'Kim';
            this.age = 15;
        }

        var 학생1 = new 기계();
        var 학생2 = new 기계();
    //new라는 키워드를 쓰신 다음 오른쪽에 기계(constructor) 이름을 쓰면 기계로부터 새로운 오브젝트를 하나를 뽑아낼 수 있습니다. 
    //그리고 그걸 변수에 저장하시면 이제 자유롭게 오브젝트를 뽑아 쓸수 있습니다.
    //기계를 사용하면 비슷한 + 독립적인 object 자료를 여러개 만들 때 코드의 양이 줄어듭니다.

    //오브젝트에 함수가 들어가야 한다면
    var 학생1 = {
            name: 'Kim',
            age: 15 
    sayHi: function () {
                console.log('안녕하세요' + this.name + ' 입니다');
            }
        };

        학생1.sayHi();
    //학생1.sayHi()하면 콘솔에 "안녕하세요 'Kim'입니다"라고 이름이 포함된 말이 출력됩니다.
    //그런데 앞으로 모든 학생들이 sayHi()를 쓸 수 있게 만들고 싶으면 어떻게 해야할까요? =>오브젝트 생성기계에 추가한다
    function 기계() {
        this.name = 'Kim';
        this.age = 15;
        this.sayHi = function () {
            console.log('안녕하세요' + this.name + ' 입니다');
        }
    }
    var 학생1 = new 기계();
    var 학생2 = new 기계();

    학생2.sayHi();
    //기계에 this.sayHi 를 추가하시면 이제 기계로부터 생성되는 모든 학생들이 sayHi()를 가지고 있게 됩니다. 그럼 학생1, 학생2 전부 sayHi()를 쓸 수 있게됩니다. 

    //학생 오브젝트를 뽑을 때 각각 다른 name, age 값을 부여하고 싶다면
    //바로 위의 코드를 보면 학생1이나 학생2나 name이 똑같은데 만약 name 속성을 각각 다르게 해서 뽑고싶으면 함수에 파라미터를 추가하는 방식을 사용하면 됩니다.
    function 기계(이름) {
            this.name = 이름;
            this.age = 15;
            this.sayHi = function () {
                console.log('안녕하세요' + this.name + ' 입니다');
            }
        }
        var 학생1 = new 기계('Park');
        var 학생2 = new 기계('Kim');
    //함수에 파라미터를 추가한다면 앞으로 기계라는 함수를 쓸 때마다파라미터자리에 데이터를 넣어서 실행할 수 있는 것입니다. =>'Park','Kim'
    //그 'Park' 이라는 데이터는 파라미터자리에 쏙 들어가서 함수가 실행되게 되며 그럼 새로 생성되는 오브젝트의 name속성은 'Park'이 됩니다. (this.name = 'Park')
    //학생1은 { name: 'Park', age : 15 } 학생2는 { name: 'Kim', age : 15 }

    //constructor은 객체지향 용어로 상속(inheritance)라고 합니다.
    //기계라는 constructor가 가진 name, age 속성들을 그대로 물려받아서 오브젝트를 하나 뽑아주는걸 상속이라고 부릅니다. (그래서 상속해주는 것은 부모, 상속받는 오브젝트들은 자식이라고 많이 비유해서 부릅니다.)
    // constructor 말고도 상속기능을 구현할 수 있는 장치가 하나 더 있습니다. prototype입니다.
    //기계를 만드시면 prototype이라는 항목이 기계 안에 몰래 생성됩니다. 
    function 기계() {
            this.name = 'Kim';
            this.age = 15;
        }
        var 학생1 = new 기계();
        var 학생2 = new 기계();

        console.log(기계.prototype);
        //prototype이라는 공간은 바로 부모의 유전자역할을 해주는 일종의 비밀 공간이다.
        //prototype은 자식들이 물려받을 수 있는 유전자로 기계.prototype은 기계의 유전자입니다. 기계.prototype 에 뭔가 변수나 함수가 들어가있다면 기계로부터 생성되는 새로운 오브젝트들(자식들)은 전부 그걸 그대로 물려받아 쓸 수 있습니다.
       
        //예를 들어
        function 기계() {
                this.name = 'Kim';
                this.age = 15;
            }

            기계.prototype.gender = '남';
            var 학생1 = new 기계();
            var 학생2 = new 기계();

            console.log(학생1.gender); //'남'이 출력됩니다
            //기계의 prototype이라는 곳에 { gender : '남' } 이라는 key/value 한쌍을 저장했습니다. (prototype은 오브젝트 자료형 다루듯이 하면 됩니다)
            //기계의 prototype, 즉 유전자에 gender: '남'이라는 데이터를 추가한 것입니다. 이제 학생1, 학생2 같은 기계로부터 생성되는 모든 자식들은 gender라는 속성을 사용할 수 있습니다. 
            //결론은 prototype 이라는 비밀 공간을 이용하시면 똑같이 상속기능을 만들 수 있습니다. 
            //1.prototype에는 값을 여러개 부여할 수도 있고 심지어 함수도 집어넣으실 수 있습니다.object 자료처럼 다뤄주시면 됩니다. 
            //2.prototype에 추가된 데이터들은 자식들이 직접 가지는게 아니라 부모만 가지고 있습니다. 

            //<prototype으로 상속시키는거랑 constructor로 상속시키는거랑 차이>
            //자식들이 값을 직접 소유하게 만들고 싶으면 constructor로 상속시키시면 되고 부모만 가지고 있고 그걸 참조해서 쓰게 만들고 싶으면 prototype으로 상속시키면 됩니다.

            // prototype 특징!!
            //1.prototype은 constructor 함수에만 생성됩니다. <= 일반 object 같은걸 상속하고 싶을땐 constructor 함수를 만들거나 Object.create()를 쓰거나 class를 쓰거나 셋중 하나를 사용하면 된다.
            //2.내 부모님 유전자를 찾고 싶다면 __proto__를 출력해보시면 됩니다. => 부모로부터 생성된 자식 object들은 __proto__라는 속성이 있습니다. 이걸 출력하면 부모의 prototype이 출력됩니다. 그래서 __proto__는 부모의 prototype과 같은 의미입니다. 
            function 기계() {
                    this.name = 'Kim';
                    this.age = 15;
                }
                var 학생1 = new 기계();
                console.log(학생1.__proto__);
                console.log(기계.prototype);
            //출력해보면 학생1.__proto__ 기계.prototype 둘다 똑같이 나옵니다.  그래서 __proto__는 부모 prototype을 의미합니다. __proto__는 내 부모 유전자가 뭔지 유전자 검사하고 싶을 때 사용하면 됩니다.

            //3.__proto__를 직접 등록하면 object끼리 상속기능을 구현가능합니다.
            var 부모 = { name: 'Kim' };
                var 자식 = {};

                자식.__proto__ = 부모;
                console.log(자식.name);
            //부모와 자식 object를 하나씩 만들고 셋째줄에서 자식의 __proto__에 부모를 집어넣었습니다. 그렇게되면 자식의 부모 유전자는 { name: 'Kim' } 이라는 오브젝트가 되는 것입니다.
            //그렇게 되면 자식은 이제 자식.name 속성을 자유롭게 사용할 수 있습니다. 

            //4.콘솔창에 prototype 정보들이 항상 출력됩니다.
            function 기계() {
                    this.name = 'Kim';
                    this.age = 15;
                }
                기계.prototype.gender = '남';

                var 학생1 = new 기계();
            //출력하면 __proto__ 가 나옵니다.  __proto__는 부모의 유전자로 기계.prototype이랑 똑같은 내용이 출력됩니다.
            //그리고 기계.prototype의 __proto__도 조회가능합니다.=>기계.prototype의 부모 유전자
            //이런식으로 나의 부모의 부모까지 탐색할 수 있습니다. 탐색하면 모든 object 자료형의 조상은 Object() 라는 기계이며(일명 Object.prototype) 모든 array 자료형의 조상도 Object()입니다. (중간에 Array()라는 부모도 있습니다.)
            //모든 함수 자료형의 조상도 Object() 입니다. =>그래서 자바스크립트는 모든게 다 Object라고 말하는 것입니다.
    </script>
  
</body>
</html>