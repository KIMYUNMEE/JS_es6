<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
    //object를 안전하게 많이 복사해 만들 수 있는 constructor라는 문법
    function 기계() {
            this.name = 'Kim';
            this.age = 15;
        }
    //object 자료 복사 기계만들 땐 function이라는 함수만드는 키워드로 만듭니다.
    //function을 만들고 그 안에 this.name과 this.age를 넣으면 됩니다. 이게 오브젝트 생성 기계입니다
    //this는 새로생성되는 오브젝트를 뜻합니다. 개발용어로는 인스턴스라고 합니다.
    //여기서 this란 새로생성되는 오브젝트.name은 'Kim'을 넣어주세요~ 라는 뜻입니다.

    //이제 기계에서 새로운 오브젝트를 뽑고 싶을때에는 
    function 기계() {
            this.name = 'Kim';
            this.age = 15;
        }

        var 학생1 = new 기계();
        var 학생2 = new 기계();
    //new라는 키워드를 쓰신 다음 오른쪽에 기계(constructor) 이름을 쓰면 기계로부터 새로운 오브젝트를 하나를 뽑아낼 수 있습니다. 
    //그리고 그걸 변수에 저장하시면 이제 자유롭게 오브젝트를 뽑아 쓸수 있습니다.
    //기계를 사용하면 비슷한 + 독립적인 object 자료를 여러개 만들 때 코드의 양이 줄어듭니다.

    //오브젝트에 함수가 들어가야 한다면
    var 학생1 = {
            name: 'Kim',
            age: 15 
    sayHi: function () {
                console.log('안녕하세요' + this.name + ' 입니다');
            }
        };

        학생1.sayHi();
    //학생1.sayHi()하면 콘솔에 "안녕하세요 'Kim'입니다"라고 이름이 포함된 말이 출력됩니다.
    //그런데 앞으로 모든 학생들이 sayHi()를 쓸 수 있게 만들고 싶으면 어떻게 해야할까요? =>오브젝트 생성기계에 추가한다
    function 기계() {
        this.name = 'Kim';
        this.age = 15;
        this.sayHi = function () {
            console.log('안녕하세요' + this.name + ' 입니다');
        }
    }
    var 학생1 = new 기계();
    var 학생2 = new 기계();

    학생2.sayHi();
    //기계에 this.sayHi 를 추가하시면 이제 기계로부터 생성되는 모든 학생들이 sayHi()를 가지고 있게 됩니다. 그럼 학생1, 학생2 전부 sayHi()를 쓸 수 있게됩니다. 

    //학생 오브젝트를 뽑을 때 각각 다른 name, age 값을 부여하고 싶다면
    //바로 위의 코드를 보면 학생1이나 학생2나 name이 똑같은데 만약 name 속성을 각각 다르게 해서 뽑고싶으면 함수에 파라미터를 추가하는 방식을 사용하면 됩니다.
    function 기계(이름) {
            this.name = 이름;
            this.age = 15;
            this.sayHi = function () {
                console.log('안녕하세요' + this.name + ' 입니다');
            }
        }
        var 학생1 = new 기계('Park');
        var 학생2 = new 기계('Kim');
    //함수에 파라미터를 추가한다면 앞으로 기계라는 함수를 쓸 때마다파라미터자리에 데이터를 넣어서 실행할 수 있는 것입니다. =>'Park','Kim'
    //그 'Park' 이라는 데이터는 파라미터자리에 쏙 들어가서 함수가 실행되게 되며 그럼 새로 생성되는 오브젝트의 name속성은 'Park'이 됩니다. (this.name = 'Park')
    //학생1은 { name: 'Park', age : 15 } 학생2는 { name: 'Kim', age : 15 }

    //constructor은 객체지향 용어로 상속(inheritance)라고 합니다.
    //기계라는 constructor가 가진 name, age 속성들을 그대로 물려받아서 오브젝트를 하나 뽑아주는걸 상속이라고 부릅니다. (그래서 상속해주는 것은 부모, 상속받는 오브젝트들은 자식이라고 많이 비유해서 부릅니다.)
    // constructor 말고도 상속기능을 구현할 수 있는 장치가 하나 더 있습니다. prototype입니다.
    //기계를 만드시면 prototype이라는 항목이 기계 안에 몰래 생성됩니다. 
    function 기계() {
            this.name = 'Kim';
            this.age = 15;
        }
        var 학생1 = new 기계();
        var 학생2 = new 기계();

        console.log(기계.prototype);
        //prototype이라는 공간은 바로 부모의 유전자역할을 해주는 일종의 비밀 공간이다.
        //prototype은 자식들이 물려받을 수 있는 유전자로 기계.prototype은 기계의 유전자입니다. 기계.prototype 에 뭔가 변수나 함수가 들어가있다면 기계로부터 생성되는 새로운 오브젝트들(자식들)은 전부 그걸 그대로 물려받아 쓸 수 있습니다.
       
        //예를 들어
        function 기계() {
                this.name = 'Kim';
                this.age = 15;
            }

            기계.prototype.gender = '남';
            var 학생1 = new 기계();
            var 학생2 = new 기계();

            console.log(학생1.gender); //'남'이 출력됩니다
            //기계의 prototype이라는 곳에 { gender : '남' } 이라는 key/value 한쌍을 저장했습니다. (prototype은 오브젝트 자료형 다루듯이 하면 됩니다)
            //기계의 prototype, 즉 유전자에 gender: '남'이라는 데이터를 추가한 것입니다. 이제 학생1, 학생2 같은 기계로부터 생성되는 모든 자식들은 gender라는 속성을 사용할 수 있습니다. 
            //결론은 prototype 이라는 비밀 공간을 이용하시면 똑같이 상속기능을 만들 수 있습니다. 
            //1.prototype에는 값을 여러개 부여할 수도 있고 심지어 함수도 집어넣으실 수 있습니다.object 자료처럼 다뤄주시면 됩니다. 
            //2.prototype에 추가된 데이터들은 자식들이 직접 가지는게 아니라 부모만 가지고 있습니다. 

            //<prototype으로 상속시키는거랑 constructor로 상속시키는거랑 차이>
            //자식들이 값을 직접 소유하게 만들고 싶으면 constructor로 상속시키시면 되고 부모만 가지고 있고 그걸 참조해서 쓰게 만들고 싶으면 prototype으로 상속시키면 됩니다.

            // prototype 특징!!
            //1.prototype은 constructor 함수에만 생성됩니다. <= 일반 object 같은걸 상속하고 싶을땐 constructor 함수를 만들거나 Object.create()를 쓰거나 class를 쓰거나 셋중 하나를 사용하면 된다.
            //2.내 부모님 유전자를 찾고 싶다면 __proto__를 출력해보시면 됩니다. => 부모로부터 생성된 자식 object들은 __proto__라는 속성이 있습니다. 이걸 출력하면 부모의 prototype이 출력됩니다. 그래서 __proto__는 부모의 prototype과 같은 의미입니다. 
            function 기계() {
                    this.name = 'Kim';
                    this.age = 15;
                }
                var 학생1 = new 기계();
                console.log(학생1.__proto__);
                console.log(기계.prototype);
            //출력해보면 학생1.__proto__ 기계.prototype 둘다 똑같이 나옵니다.  그래서 __proto__는 부모 prototype을 의미합니다. __proto__는 내 부모 유전자가 뭔지 유전자 검사하고 싶을 때 사용하면 됩니다.

            //3.__proto__를 직접 등록하면 object끼리 상속기능을 구현가능합니다.
            var 부모 = { name: 'Kim' };
                var 자식 = {};

                자식.__proto__ = 부모;
                console.log(자식.name);
            //부모와 자식 object를 하나씩 만들고 셋째줄에서 자식의 __proto__에 부모를 집어넣었습니다. 그렇게되면 자식의 부모 유전자는 { name: 'Kim' } 이라는 오브젝트가 되는 것입니다.
            //그렇게 되면 자식은 이제 자식.name 속성을 자유롭게 사용할 수 있습니다. 

            //4.콘솔창에 prototype 정보들이 항상 출력됩니다.
            function 기계() {
                    this.name = 'Kim';
                    this.age = 15;
                }
                기계.prototype.gender = '남';

                var 학생1 = new 기계();
            //출력하면 __proto__ 가 나옵니다.  __proto__는 부모의 유전자로 기계.prototype이랑 똑같은 내용이 출력됩니다.
            //그리고 기계.prototype의 __proto__도 조회가능합니다.=>기계.prototype의 부모 유전자
            //이런식으로 나의 부모의 부모까지 탐색할 수 있습니다. 탐색하면 모든 object 자료형의 조상은 Object() 라는 기계이며(일명 Object.prototype) 모든 array 자료형의 조상도 Object()입니다. (중간에 Array()라는 부모도 있습니다.)
            //모든 함수 자료형의 조상도 Object() 입니다. =>그래서 자바스크립트는 모든게 다 Object라고 말하는 것입니다.

            //prototype이나,this,class보다 더쉬운 상속을 이용해서 오브젝트를 만드는 방법은 ES5방식이 있는데 인지도는 낮습니다.=>Object.create()
            var 부모 = { name: 'Kim', age: 50 };
                var 자식 = Object.create(부모);

                console.log(자식.age); //50나옴
            //Object.create(부모object);는 이 자리에 오브젝트 자료형 하나가 남습니다. 그리고 소괄호 안에 적은 부모object가 유전자(prototype)가 되는 것입니다.
            //위의 예제를 보면 자식이라는 object는 부모를 prototype으로 두게 됩니다. 자식.name 해도 'Kim'이 출력되고 자식.age 해도 50이 출력됩니다.(이렇게 하면 쉽게 상속할 수 있습니다.)

            //위의 예제의 age를 20으로 바꾸고 싶다면?
            var 부모 = { name: 'Kim', age: 50 };
                var 자식 = Object.create(부모);
                자식.age = 20;

                console.log(자식.age); //20 나옴
            //자식이라는 object에 age : 20 이라는 값을 부여하면 자식.age 할 때마다 20이 출력됩니다.
            //Q:부모로부터 상속받은 50이라는 age가 출력되지 않는 이유는?
            //A:자바스크립트 오브젝트 자료형에서 특정 자료를 꺼낼 때 묻는 순서가 있다고 배웠었습니다. 자식.age를 꺼내주세요~라고 하면
            //A:1. 자식이라는 object가 직접 age를 가지고 있으면 그거 출력 2. 없으면 자식의 부모 prototype을 뒤져서 age가 거기 있으면 그거 출력 3. 거기도 없으면 부모의 부모 prototype을 탐색해서..
            //위와 같은 순서로 age를 출력하기 때문에 자식이 20이 나오는 것입니다.
            
            //자식을 넘어서 손자를 만드려면?
            var 부모 = { name: 'Kim', age: 50 };
                var 자식 = Object.create(부모);
                자식.age = 20;

                var 손자 = Object.create(자식);

                console.log(손자.age);
            //손자는 자식과 부모가 가진 속성들을 전부 물려받습니다. 그래서 손자.age는 20이 출력됩니다.
            //Q:20이 나오는 이유는?
            //A:1. 손자에 age가 있는지 확인하고 2. 없으면 부모 prototype에 있는지 확인하고 3. 거기도 없으면 부모의 부모 prototype에 있는지 확인하고..
            //A:이렇게 하나씩 확인해서 젤 가까운 age를 출력시키기 때문입니다. 
            
    </script>
  
</body>
</html>